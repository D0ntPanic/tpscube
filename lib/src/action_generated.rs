// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PENALTY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PENALTY: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PENALTY: [Penalty; 3] = [
  Penalty::NONE,
  Penalty::TimePenalty,
  Penalty::DNFPenalty,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Penalty(pub u8);
#[allow(non_upper_case_globals)]
impl Penalty {
  pub const NONE: Self = Self(0);
  pub const TimePenalty: Self = Self(1);
  pub const DNFPenalty: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::TimePenalty,
    Self::DNFPenalty,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::TimePenalty => Some("TimePenalty"),
      Self::DNFPenalty => Some("DNFPenalty"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Penalty {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Penalty {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Penalty {
    type Output = Penalty;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Penalty {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Penalty {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Penalty {}
pub struct PenaltyUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ACTION_CONTENTS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ACTION_CONTENTS: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ACTION_CONTENTS: [ActionContents; 7] = [
  ActionContents::NONE,
  ActionContents::NewSolveAction,
  ActionContents::PenaltyAction,
  ActionContents::ChangeSessionAction,
  ActionContents::MergeSessionsAction,
  ActionContents::RenameSessionAction,
  ActionContents::DeleteSolveAction,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ActionContents(pub u8);
#[allow(non_upper_case_globals)]
impl ActionContents {
  pub const NONE: Self = Self(0);
  pub const NewSolveAction: Self = Self(1);
  pub const PenaltyAction: Self = Self(2);
  pub const ChangeSessionAction: Self = Self(3);
  pub const MergeSessionsAction: Self = Self(4);
  pub const RenameSessionAction: Self = Self(5);
  pub const DeleteSolveAction: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::NewSolveAction,
    Self::PenaltyAction,
    Self::ChangeSessionAction,
    Self::MergeSessionsAction,
    Self::RenameSessionAction,
    Self::DeleteSolveAction,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::NewSolveAction => Some("NewSolveAction"),
      Self::PenaltyAction => Some("PenaltyAction"),
      Self::ChangeSessionAction => Some("ChangeSessionAction"),
      Self::MergeSessionsAction => Some("MergeSessionsAction"),
      Self::RenameSessionAction => Some("RenameSessionAction"),
      Self::DeleteSolveAction => Some("DeleteSolveAction"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for ActionContents {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ActionContents {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for ActionContents {
    type Output = ActionContents;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ActionContents {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ActionContents {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ActionContents {}
pub struct ActionContentsUnionTableOffset {}

// struct TimedMove, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct TimedMove(pub [u8; 8]);
impl Default for TimedMove { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl std::fmt::Debug for TimedMove {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("TimedMove")
      .field("move_", &self.move_())
      .field("time", &self.time())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TimedMove {}
impl flatbuffers::SafeSliceAccess for TimedMove {}
impl<'a> flatbuffers::Follow<'a> for TimedMove {
  type Inner = &'a TimedMove;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a TimedMove>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a TimedMove {
  type Inner = &'a TimedMove;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<TimedMove>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for TimedMove {
    type Output = TimedMove;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const TimedMove as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b TimedMove {
    type Output = TimedMove;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const TimedMove as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for TimedMove {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> TimedMove {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    move_: u8,
    time: u32,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_move_(move_);
    s.set_time(time);
    s
  }

  pub fn move_(&self) -> u8 {
    let mut mem = core::mem::MaybeUninit::<u8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<u8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_move_(&mut self, x: u8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const u8 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<u8>(),
      );
    }
  }

  pub fn time(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<u32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<u32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_time(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const u32 as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<u32>(),
      );
    }
  }

}

pub enum TimePenaltyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TimePenalty<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TimePenalty<'a> {
    type Inner = TimePenalty<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> TimePenalty<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TimePenalty { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TimePenaltyArgs) -> flatbuffers::WIPOffset<TimePenalty<'bldr>> {
      let mut builder = TimePenaltyBuilder::new(_fbb);
      builder.add_time(args.time);
      builder.finish()
    }

    pub const VT_TIME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn time(&self) -> u32 {
    self._tab.get::<u32>(TimePenalty::VT_TIME, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for TimePenalty<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"time", Self::VT_TIME, false)?
     .finish();
    Ok(())
  }
}
pub struct TimePenaltyArgs {
    pub time: u32,
}
impl<'a> Default for TimePenaltyArgs {
    #[inline]
    fn default() -> Self {
        TimePenaltyArgs {
            time: 0,
        }
    }
}
pub struct TimePenaltyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TimePenaltyBuilder<'a, 'b> {
  #[inline]
  pub fn add_time(&mut self, time: u32) {
    self.fbb_.push_slot::<u32>(TimePenalty::VT_TIME, time, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimePenaltyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TimePenaltyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TimePenalty<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for TimePenalty<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("TimePenalty");
      ds.field("time", &self.time());
      ds.finish()
  }
}
pub enum DNFPenaltyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DNFPenalty<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DNFPenalty<'a> {
    type Inner = DNFPenalty<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> DNFPenalty<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DNFPenalty { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args DNFPenaltyArgs) -> flatbuffers::WIPOffset<DNFPenalty<'bldr>> {
      let mut builder = DNFPenaltyBuilder::new(_fbb);
      builder.finish()
    }

}

impl flatbuffers::Verifiable for DNFPenalty<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct DNFPenaltyArgs {
}
impl<'a> Default for DNFPenaltyArgs {
    #[inline]
    fn default() -> Self {
        DNFPenaltyArgs {
        }
    }
}
pub struct DNFPenaltyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DNFPenaltyBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DNFPenaltyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DNFPenaltyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DNFPenalty<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for DNFPenalty<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("DNFPenalty");
      ds.finish()
  }
}
pub enum NewSolveActionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NewSolveAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NewSolveAction<'a> {
    type Inner = NewSolveAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> NewSolveAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NewSolveAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NewSolveActionArgs<'args>) -> flatbuffers::WIPOffset<NewSolveAction<'bldr>> {
      let mut builder = NewSolveActionBuilder::new(_fbb);
      builder.add_created(args.created);
      if let Some(x) = args.moves { builder.add_moves(x); }
      if let Some(x) = args.device { builder.add_device(x); }
      if let Some(x) = args.penalty { builder.add_penalty(x); }
      builder.add_time(args.time);
      if let Some(x) = args.scramble { builder.add_scramble(x); }
      if let Some(x) = args.session { builder.add_session(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      builder.add_penalty_type(args.penalty_type);
      builder.add_solve_type(args.solve_type);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SOLVE_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SESSION: flatbuffers::VOffsetT = 8;
    pub const VT_SCRAMBLE: flatbuffers::VOffsetT = 10;
    pub const VT_CREATED: flatbuffers::VOffsetT = 12;
    pub const VT_TIME: flatbuffers::VOffsetT = 14;
    pub const VT_PENALTY_TYPE: flatbuffers::VOffsetT = 16;
    pub const VT_PENALTY: flatbuffers::VOffsetT = 18;
    pub const VT_DEVICE: flatbuffers::VOffsetT = 20;
    pub const VT_MOVES: flatbuffers::VOffsetT = 22;

  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NewSolveAction::VT_ID, None)
  }
  #[inline]
  pub fn solve_type(&self) -> u8 {
    self._tab.get::<u8>(NewSolveAction::VT_SOLVE_TYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn session(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NewSolveAction::VT_SESSION, None)
  }
  #[inline]
  pub fn scramble(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(NewSolveAction::VT_SCRAMBLE, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn created(&self) -> i64 {
    self._tab.get::<i64>(NewSolveAction::VT_CREATED, Some(0)).unwrap()
  }
  #[inline]
  pub fn time(&self) -> u32 {
    self._tab.get::<u32>(NewSolveAction::VT_TIME, Some(0)).unwrap()
  }
  #[inline]
  pub fn penalty_type(&self) -> Penalty {
    self._tab.get::<Penalty>(NewSolveAction::VT_PENALTY_TYPE, Some(Penalty::NONE)).unwrap()
  }
  #[inline]
  pub fn penalty(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(NewSolveAction::VT_PENALTY, None)
  }
  #[inline]
  pub fn device(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NewSolveAction::VT_DEVICE, None)
  }
  #[inline]
  pub fn moves(&self) -> Option<&'a [TimedMove]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, TimedMove>>>(NewSolveAction::VT_MOVES, None).map(|v| v.safe_slice())
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn penalty_as_time_penalty(&self) -> Option<TimePenalty<'a>> {
    if self.penalty_type() == Penalty::TimePenalty {
      self.penalty().map(TimePenalty::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn penalty_as_dnfpenalty(&self) -> Option<DNFPenalty<'a>> {
    if self.penalty_type() == Penalty::DNFPenalty {
      self.penalty().map(DNFPenalty::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for NewSolveAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"id", Self::VT_ID, false)?
     .visit_field::<u8>(&"solve_type", Self::VT_SOLVE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"session", Self::VT_SESSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"scramble", Self::VT_SCRAMBLE, false)?
     .visit_field::<i64>(&"created", Self::VT_CREATED, false)?
     .visit_field::<u32>(&"time", Self::VT_TIME, false)?
     .visit_union::<Penalty, _>(&"penalty_type", Self::VT_PENALTY_TYPE, &"penalty", Self::VT_PENALTY, false, |key, v, pos| {
        match key {
          Penalty::TimePenalty => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TimePenalty>>("Penalty::TimePenalty", pos),
          Penalty::DNFPenalty => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DNFPenalty>>("Penalty::DNFPenalty", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"device", Self::VT_DEVICE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, TimedMove>>>(&"moves", Self::VT_MOVES, false)?
     .finish();
    Ok(())
  }
}
pub struct NewSolveActionArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub solve_type: u8,
    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scramble: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub created: i64,
    pub time: u32,
    pub penalty_type: Penalty,
    pub penalty: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub device: Option<flatbuffers::WIPOffset<&'a str>>,
    pub moves: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, TimedMove>>>,
}
impl<'a> Default for NewSolveActionArgs<'a> {
    #[inline]
    fn default() -> Self {
        NewSolveActionArgs {
            id: None,
            solve_type: 0,
            session: None,
            scramble: None,
            created: 0,
            time: 0,
            penalty_type: Penalty::NONE,
            penalty: None,
            device: None,
            moves: None,
        }
    }
}
pub struct NewSolveActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NewSolveActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NewSolveAction::VT_ID, id);
  }
  #[inline]
  pub fn add_solve_type(&mut self, solve_type: u8) {
    self.fbb_.push_slot::<u8>(NewSolveAction::VT_SOLVE_TYPE, solve_type, 0);
  }
  #[inline]
  pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NewSolveAction::VT_SESSION, session);
  }
  #[inline]
  pub fn add_scramble(&mut self, scramble: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NewSolveAction::VT_SCRAMBLE, scramble);
  }
  #[inline]
  pub fn add_created(&mut self, created: i64) {
    self.fbb_.push_slot::<i64>(NewSolveAction::VT_CREATED, created, 0);
  }
  #[inline]
  pub fn add_time(&mut self, time: u32) {
    self.fbb_.push_slot::<u32>(NewSolveAction::VT_TIME, time, 0);
  }
  #[inline]
  pub fn add_penalty_type(&mut self, penalty_type: Penalty) {
    self.fbb_.push_slot::<Penalty>(NewSolveAction::VT_PENALTY_TYPE, penalty_type, Penalty::NONE);
  }
  #[inline]
  pub fn add_penalty(&mut self, penalty: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NewSolveAction::VT_PENALTY, penalty);
  }
  #[inline]
  pub fn add_device(&mut self, device: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NewSolveAction::VT_DEVICE, device);
  }
  #[inline]
  pub fn add_moves(&mut self, moves: flatbuffers::WIPOffset<flatbuffers::Vector<'b , TimedMove>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NewSolveAction::VT_MOVES, moves);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NewSolveActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NewSolveActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NewSolveAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for NewSolveAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("NewSolveAction");
      ds.field("id", &self.id());
      ds.field("solve_type", &self.solve_type());
      ds.field("session", &self.session());
      ds.field("scramble", &self.scramble());
      ds.field("created", &self.created());
      ds.field("time", &self.time());
      ds.field("penalty_type", &self.penalty_type());
      match self.penalty_type() {
        Penalty::TimePenalty => {
          if let Some(x) = self.penalty_as_time_penalty() {
            ds.field("penalty", &x)
          } else {
            ds.field("penalty", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Penalty::DNFPenalty => {
          if let Some(x) = self.penalty_as_dnfpenalty() {
            ds.field("penalty", &x)
          } else {
            ds.field("penalty", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("penalty", &x)
        },
      };
      ds.field("device", &self.device());
      ds.field("moves", &self.moves());
      ds.finish()
  }
}
pub enum PenaltyActionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PenaltyAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PenaltyAction<'a> {
    type Inner = PenaltyAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> PenaltyAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PenaltyAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PenaltyActionArgs<'args>) -> flatbuffers::WIPOffset<PenaltyAction<'bldr>> {
      let mut builder = PenaltyActionBuilder::new(_fbb);
      if let Some(x) = args.penalty { builder.add_penalty(x); }
      if let Some(x) = args.solve { builder.add_solve(x); }
      builder.add_penalty_type(args.penalty_type);
      builder.finish()
    }

    pub const VT_SOLVE: flatbuffers::VOffsetT = 4;
    pub const VT_PENALTY_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_PENALTY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn solve(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PenaltyAction::VT_SOLVE, None)
  }
  #[inline]
  pub fn penalty_type(&self) -> Penalty {
    self._tab.get::<Penalty>(PenaltyAction::VT_PENALTY_TYPE, Some(Penalty::NONE)).unwrap()
  }
  #[inline]
  pub fn penalty(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(PenaltyAction::VT_PENALTY, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn penalty_as_time_penalty(&self) -> Option<TimePenalty<'a>> {
    if self.penalty_type() == Penalty::TimePenalty {
      self.penalty().map(TimePenalty::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn penalty_as_dnfpenalty(&self) -> Option<DNFPenalty<'a>> {
    if self.penalty_type() == Penalty::DNFPenalty {
      self.penalty().map(DNFPenalty::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for PenaltyAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"solve", Self::VT_SOLVE, false)?
     .visit_union::<Penalty, _>(&"penalty_type", Self::VT_PENALTY_TYPE, &"penalty", Self::VT_PENALTY, false, |key, v, pos| {
        match key {
          Penalty::TimePenalty => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TimePenalty>>("Penalty::TimePenalty", pos),
          Penalty::DNFPenalty => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DNFPenalty>>("Penalty::DNFPenalty", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct PenaltyActionArgs<'a> {
    pub solve: Option<flatbuffers::WIPOffset<&'a str>>,
    pub penalty_type: Penalty,
    pub penalty: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PenaltyActionArgs<'a> {
    #[inline]
    fn default() -> Self {
        PenaltyActionArgs {
            solve: None,
            penalty_type: Penalty::NONE,
            penalty: None,
        }
    }
}
pub struct PenaltyActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PenaltyActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_solve(&mut self, solve: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PenaltyAction::VT_SOLVE, solve);
  }
  #[inline]
  pub fn add_penalty_type(&mut self, penalty_type: Penalty) {
    self.fbb_.push_slot::<Penalty>(PenaltyAction::VT_PENALTY_TYPE, penalty_type, Penalty::NONE);
  }
  #[inline]
  pub fn add_penalty(&mut self, penalty: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PenaltyAction::VT_PENALTY, penalty);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PenaltyActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PenaltyActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PenaltyAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for PenaltyAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("PenaltyAction");
      ds.field("solve", &self.solve());
      ds.field("penalty_type", &self.penalty_type());
      match self.penalty_type() {
        Penalty::TimePenalty => {
          if let Some(x) = self.penalty_as_time_penalty() {
            ds.field("penalty", &x)
          } else {
            ds.field("penalty", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Penalty::DNFPenalty => {
          if let Some(x) = self.penalty_as_dnfpenalty() {
            ds.field("penalty", &x)
          } else {
            ds.field("penalty", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("penalty", &x)
        },
      };
      ds.finish()
  }
}
pub enum ChangeSessionActionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ChangeSessionAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ChangeSessionAction<'a> {
    type Inner = ChangeSessionAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ChangeSessionAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ChangeSessionAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ChangeSessionActionArgs<'args>) -> flatbuffers::WIPOffset<ChangeSessionAction<'bldr>> {
      let mut builder = ChangeSessionActionBuilder::new(_fbb);
      if let Some(x) = args.session { builder.add_session(x); }
      if let Some(x) = args.solve { builder.add_solve(x); }
      builder.finish()
    }

    pub const VT_SOLVE: flatbuffers::VOffsetT = 4;
    pub const VT_SESSION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn solve(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ChangeSessionAction::VT_SOLVE, None)
  }
  #[inline]
  pub fn session(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ChangeSessionAction::VT_SESSION, None)
  }
}

impl flatbuffers::Verifiable for ChangeSessionAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"solve", Self::VT_SOLVE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"session", Self::VT_SESSION, false)?
     .finish();
    Ok(())
  }
}
pub struct ChangeSessionActionArgs<'a> {
    pub solve: Option<flatbuffers::WIPOffset<&'a str>>,
    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ChangeSessionActionArgs<'a> {
    #[inline]
    fn default() -> Self {
        ChangeSessionActionArgs {
            solve: None,
            session: None,
        }
    }
}
pub struct ChangeSessionActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChangeSessionActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_solve(&mut self, solve: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ChangeSessionAction::VT_SOLVE, solve);
  }
  #[inline]
  pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ChangeSessionAction::VT_SESSION, session);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ChangeSessionActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChangeSessionActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ChangeSessionAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ChangeSessionAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ChangeSessionAction");
      ds.field("solve", &self.solve());
      ds.field("session", &self.session());
      ds.finish()
  }
}
pub enum MergeSessionsActionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MergeSessionsAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeSessionsAction<'a> {
    type Inner = MergeSessionsAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MergeSessionsAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeSessionsAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MergeSessionsActionArgs<'args>) -> flatbuffers::WIPOffset<MergeSessionsAction<'bldr>> {
      let mut builder = MergeSessionsActionBuilder::new(_fbb);
      if let Some(x) = args.second { builder.add_second(x); }
      if let Some(x) = args.first { builder.add_first(x); }
      builder.finish()
    }

    pub const VT_FIRST: flatbuffers::VOffsetT = 4;
    pub const VT_SECOND: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn first(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MergeSessionsAction::VT_FIRST, None)
  }
  #[inline]
  pub fn second(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MergeSessionsAction::VT_SECOND, None)
  }
}

impl flatbuffers::Verifiable for MergeSessionsAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"first", Self::VT_FIRST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"second", Self::VT_SECOND, false)?
     .finish();
    Ok(())
  }
}
pub struct MergeSessionsActionArgs<'a> {
    pub first: Option<flatbuffers::WIPOffset<&'a str>>,
    pub second: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MergeSessionsActionArgs<'a> {
    #[inline]
    fn default() -> Self {
        MergeSessionsActionArgs {
            first: None,
            second: None,
        }
    }
}
pub struct MergeSessionsActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeSessionsActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_first(&mut self, first: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MergeSessionsAction::VT_FIRST, first);
  }
  #[inline]
  pub fn add_second(&mut self, second: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MergeSessionsAction::VT_SECOND, second);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MergeSessionsActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MergeSessionsActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MergeSessionsAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MergeSessionsAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MergeSessionsAction");
      ds.field("first", &self.first());
      ds.field("second", &self.second());
      ds.finish()
  }
}
pub enum RenameSessionActionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RenameSessionAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RenameSessionAction<'a> {
    type Inner = RenameSessionAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RenameSessionAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RenameSessionAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RenameSessionActionArgs<'args>) -> flatbuffers::WIPOffset<RenameSessionAction<'bldr>> {
      let mut builder = RenameSessionActionBuilder::new(_fbb);
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.session { builder.add_session(x); }
      builder.finish()
    }

    pub const VT_SESSION: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn session(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RenameSessionAction::VT_SESSION, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RenameSessionAction::VT_NAME, None)
  }
}

impl flatbuffers::Verifiable for RenameSessionAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"session", Self::VT_SESSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct RenameSessionActionArgs<'a> {
    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RenameSessionActionArgs<'a> {
    #[inline]
    fn default() -> Self {
        RenameSessionActionArgs {
            session: None,
            name: None,
        }
    }
}
pub struct RenameSessionActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RenameSessionActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RenameSessionAction::VT_SESSION, session);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RenameSessionAction::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RenameSessionActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RenameSessionActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RenameSessionAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RenameSessionAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RenameSessionAction");
      ds.field("session", &self.session());
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum DeleteSolveActionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DeleteSolveAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeleteSolveAction<'a> {
    type Inner = DeleteSolveAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> DeleteSolveAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DeleteSolveAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DeleteSolveActionArgs<'args>) -> flatbuffers::WIPOffset<DeleteSolveAction<'bldr>> {
      let mut builder = DeleteSolveActionBuilder::new(_fbb);
      if let Some(x) = args.solve { builder.add_solve(x); }
      builder.finish()
    }

    pub const VT_SOLVE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn solve(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DeleteSolveAction::VT_SOLVE, None)
  }
}

impl flatbuffers::Verifiable for DeleteSolveAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"solve", Self::VT_SOLVE, false)?
     .finish();
    Ok(())
  }
}
pub struct DeleteSolveActionArgs<'a> {
    pub solve: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DeleteSolveActionArgs<'a> {
    #[inline]
    fn default() -> Self {
        DeleteSolveActionArgs {
            solve: None,
        }
    }
}
pub struct DeleteSolveActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DeleteSolveActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_solve(&mut self, solve: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeleteSolveAction::VT_SOLVE, solve);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DeleteSolveActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DeleteSolveActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DeleteSolveAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for DeleteSolveAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("DeleteSolveAction");
      ds.field("solve", &self.solve());
      ds.finish()
  }
}
pub enum ActionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Action<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Action<'a> {
    type Inner = Action<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Action<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Action { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ActionArgs<'args>) -> flatbuffers::WIPOffset<Action<'bldr>> {
      let mut builder = ActionBuilder::new(_fbb);
      if let Some(x) = args.contents { builder.add_contents(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      builder.add_contents_type(args.contents_type);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_CONTENTS_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_CONTENTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Action::VT_ID, None)
  }
  #[inline]
  pub fn contents_type(&self) -> ActionContents {
    self._tab.get::<ActionContents>(Action::VT_CONTENTS_TYPE, Some(ActionContents::NONE)).unwrap()
  }
  #[inline]
  pub fn contents(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Action::VT_CONTENTS, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_new_solve_action(&self) -> Option<NewSolveAction<'a>> {
    if self.contents_type() == ActionContents::NewSolveAction {
      self.contents().map(NewSolveAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_penalty_action(&self) -> Option<PenaltyAction<'a>> {
    if self.contents_type() == ActionContents::PenaltyAction {
      self.contents().map(PenaltyAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_change_session_action(&self) -> Option<ChangeSessionAction<'a>> {
    if self.contents_type() == ActionContents::ChangeSessionAction {
      self.contents().map(ChangeSessionAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_merge_sessions_action(&self) -> Option<MergeSessionsAction<'a>> {
    if self.contents_type() == ActionContents::MergeSessionsAction {
      self.contents().map(MergeSessionsAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_rename_session_action(&self) -> Option<RenameSessionAction<'a>> {
    if self.contents_type() == ActionContents::RenameSessionAction {
      self.contents().map(RenameSessionAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn contents_as_delete_solve_action(&self) -> Option<DeleteSolveAction<'a>> {
    if self.contents_type() == ActionContents::DeleteSolveAction {
      self.contents().map(DeleteSolveAction::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Action<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"id", Self::VT_ID, false)?
     .visit_union::<ActionContents, _>(&"contents_type", Self::VT_CONTENTS_TYPE, &"contents", Self::VT_CONTENTS, false, |key, v, pos| {
        match key {
          ActionContents::NewSolveAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NewSolveAction>>("ActionContents::NewSolveAction", pos),
          ActionContents::PenaltyAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PenaltyAction>>("ActionContents::PenaltyAction", pos),
          ActionContents::ChangeSessionAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ChangeSessionAction>>("ActionContents::ChangeSessionAction", pos),
          ActionContents::MergeSessionsAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeSessionsAction>>("ActionContents::MergeSessionsAction", pos),
          ActionContents::RenameSessionAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RenameSessionAction>>("ActionContents::RenameSessionAction", pos),
          ActionContents::DeleteSolveAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DeleteSolveAction>>("ActionContents::DeleteSolveAction", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ActionArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contents_type: ActionContents,
    pub contents: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ActionArgs<'a> {
    #[inline]
    fn default() -> Self {
        ActionArgs {
            id: None,
            contents_type: ActionContents::NONE,
            contents: None,
        }
    }
}
pub struct ActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Action::VT_ID, id);
  }
  #[inline]
  pub fn add_contents_type(&mut self, contents_type: ActionContents) {
    self.fbb_.push_slot::<ActionContents>(Action::VT_CONTENTS_TYPE, contents_type, ActionContents::NONE);
  }
  #[inline]
  pub fn add_contents(&mut self, contents: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Action::VT_CONTENTS, contents);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Action<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Action<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Action");
      ds.field("id", &self.id());
      ds.field("contents_type", &self.contents_type());
      match self.contents_type() {
        ActionContents::NewSolveAction => {
          if let Some(x) = self.contents_as_new_solve_action() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ActionContents::PenaltyAction => {
          if let Some(x) = self.contents_as_penalty_action() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ActionContents::ChangeSessionAction => {
          if let Some(x) = self.contents_as_change_session_action() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ActionContents::MergeSessionsAction => {
          if let Some(x) = self.contents_as_merge_sessions_action() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ActionContents::RenameSessionAction => {
          if let Some(x) = self.contents_as_rename_session_action() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ActionContents::DeleteSolveAction => {
          if let Some(x) = self.contents_as_delete_solve_action() {
            ds.field("contents", &x)
          } else {
            ds.field("contents", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("contents", &x)
        },
      };
      ds.finish()
  }
}
pub enum ActionListOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ActionList<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ActionList<'a> {
    type Inner = ActionList<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ActionList<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ActionList { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ActionListArgs<'args>) -> flatbuffers::WIPOffset<ActionList<'bldr>> {
      let mut builder = ActionListBuilder::new(_fbb);
      if let Some(x) = args.actions { builder.add_actions(x); }
      builder.finish()
    }

    pub const VT_ACTIONS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn actions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Action<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Action>>>>(ActionList::VT_ACTIONS, None)
  }
}

impl flatbuffers::Verifiable for ActionList<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Action>>>>(&"actions", Self::VT_ACTIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct ActionListArgs<'a> {
    pub actions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Action<'a>>>>>,
}
impl<'a> Default for ActionListArgs<'a> {
    #[inline]
    fn default() -> Self {
        ActionListArgs {
            actions: None,
        }
    }
}
pub struct ActionListBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ActionListBuilder<'a, 'b> {
  #[inline]
  pub fn add_actions(&mut self, actions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Action<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ActionList::VT_ACTIONS, actions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ActionListBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ActionListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ActionList<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ActionList<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ActionList");
      ds.field("actions", &self.actions());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_action_list<'a>(buf: &'a [u8]) -> ActionList<'a> {
  unsafe { flatbuffers::root_unchecked::<ActionList<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_action_list<'a>(buf: &'a [u8]) -> ActionList<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<ActionList<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `ActionList`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_action_list_unchecked`.
pub fn root_as_action_list(buf: &[u8]) -> Result<ActionList, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ActionList>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ActionList` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_action_list_unchecked`.
pub fn size_prefixed_root_as_action_list(buf: &[u8]) -> Result<ActionList, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ActionList>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ActionList` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_action_list_unchecked`.
pub fn root_as_action_list_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ActionList<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ActionList<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ActionList` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_action_list_unchecked`.
pub fn size_prefixed_root_as_action_list_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ActionList<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ActionList<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ActionList and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ActionList`.
pub unsafe fn root_as_action_list_unchecked(buf: &[u8]) -> ActionList {
  flatbuffers::root_unchecked::<ActionList>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ActionList and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ActionList`.
pub unsafe fn size_prefixed_root_as_action_list_unchecked(buf: &[u8]) -> ActionList {
  flatbuffers::size_prefixed_root_unchecked::<ActionList>(buf)
}
#[inline]
pub fn finish_action_list_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<ActionList<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_action_list_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<ActionList<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
