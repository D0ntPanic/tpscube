#pragma once

#include <stddef.h>
#include "cubecommon.h"
#include "scramble.h"

#define CORNER_ORIENTATION_INDEX_COUNT 2187 // 3**7
#define CORNER_PERMUTATION_INDEX_COUNT 40320 // 8!
#define EDGE_ORIENTATION_INDEX_COUNT 2048 // 2**11e
#define PHASE_2_EDGE_PERMUTATION_INDEX_COUNT 40320 // 8!
#define EDGE_SLICE_INDEX_COUNT 495 // NChooseK(12, 4)
#define PHASE_2_EQUATORIAL_EDGE_PERMUTATION_INDEX_COUNT 24 // 4!

#define MAX_3x3_PHASE_1_MOVES 12
#define MAX_3x3_PHASE_2_MOVES 18
#define MAX_3X3_SOLUTION_MOVES (MAX_3x3_PHASE_1_MOVES + MAX_3x3_PHASE_2_MOVES)

// A CubePiece is an identification of a piece (CubeCorner or CubeEdge)
// and an orientation (flip or twist from solved state). A full cube state
// can be represented as the pieces and orientations making up the cube
// instead of the face colors (this makes generating random cube states
// much easier).
struct CubePiece
{
	uint8_t piece;
	uint8_t orientation; // 0 or 1 (flip) for edges, 0-2 (twist) for corners

	bool operator==(const CubePiece& other) const;
	bool operator!=(const CubePiece& other) const;
};

class Cube3x3Faces;

// Representation of a 3x3x3 cube using piece format
class Cube3x3
{
	CubePiece m_corners[8];
	CubePiece m_edges[12];

	static CubePiece m_cornerRotation[2][6][8];
	static CubePiece m_edgeRotation[2][6][12];
	static CubeColor m_cornerColors[8][3];
	static CubeColor m_edgeColors[12][2];

	// These tables contain the effect of all moves on each type of index used to identify various asepcts of the
	// cube's state. This is used during solving to quickly move between states using precomputed information.
	// These are generated by tools/gentables3x3.cpp
	static int m_cornerOrientationMoveTable[CORNER_ORIENTATION_INDEX_COUNT][MOVE_D2 + 1];
	static int m_cornerPermutationMoveTable[CORNER_PERMUTATION_INDEX_COUNT][MOVE_D2 + 1];
	static int m_edgeOrientationMoveTable[EDGE_ORIENTATION_INDEX_COUNT][MOVE_D2 + 1];
	static int m_equatorialEdgeSliceMoveTable[EDGE_SLICE_INDEX_COUNT][MOVE_D2 + 1];
	static int m_phase2EdgePermutationMoveTable[PHASE_2_EDGE_PERMUTATION_INDEX_COUNT][MOVE_D2 + 1];
	static int m_phase2EquatorialEdgePermutationMoveTable[PHASE_2_EQUATORIAL_EDGE_PERMUTATION_INDEX_COUNT][MOVE_D2 + 1];

	// These tables contain the minimum number of moves to solve given indicies that identify aspects of the
	// cube's state. These can be used during solving to prune the search space if the current state cannot
	// be solved in the desired number of moves. These are generated by tools/gentables3x3.cpp
	static uint8_t m_cornerOrientationPruneTable[CORNER_ORIENTATION_INDEX_COUNT][EDGE_SLICE_INDEX_COUNT];
	static uint8_t m_edgeOrientationPruneTable[EDGE_ORIENTATION_INDEX_COUNT][EDGE_SLICE_INDEX_COUNT];
	static uint8_t m_cornerPermutationPruneTable[CORNER_PERMUTATION_INDEX_COUNT][PHASE_2_EQUATORIAL_EDGE_PERMUTATION_INDEX_COUNT];
	static uint8_t m_phase2EdgePermutationPruneTable[PHASE_2_EDGE_PERMUTATION_INDEX_COUNT][PHASE_2_EQUATORIAL_EDGE_PERMUTATION_INDEX_COUNT];

	struct PossibleSearchMoves
	{
		int count;
		CubeMove moves[MOVE_D2 + 1];
	};

	// Set of moves that are allowed in each phase and following given moves. For example, L should never follow L'.
	// Also, avoid move sequences like L R L by forcing opposite faces to be turned only in a single order.
	static PossibleSearchMoves m_possiblePhase1Moves;
	static PossibleSearchMoves m_possiblePhase1FollowupMoves[MOVE_D2 + 1];
	static PossibleSearchMoves m_possiblePhase2Moves;
	static PossibleSearchMoves m_possiblePhase2FollowupMoves[MOVE_D2 + 1];

	struct Phase1IndexCube
	{
		int cornerOrientation;
		int edgeOrientation;
		int equatorialEdgeSlice;
	};

	struct Phase2IndexCube
	{
		int cornerPermutation;
		int edgePermutation;
		int equatorialEdgePermutation;
	};

	struct SearchMoveSequence
	{
		CubeMove moves[MAX_3X3_SOLUTION_MOVES];
		int count;
	};

	static void SearchPhase1(const Cube3x3& initialState, const Phase1IndexCube& cube, int depth,
		SearchMoveSequence& moves, CubeMoveSequence& bestSolution, int& maxMoves, bool optimal);
	static void SearchPhase2(const Phase2IndexCube& cube, int depth, SearchMoveSequence& moves,
		CubeMoveSequence& bestSolution, int& maxMoves, bool optimal);

public:
	Cube3x3();
	Cube3x3(const Cube3x3Faces& cube);

	void Rotate(CubeFace face, CubeRotationDirection dir);
	void Move(CubeMove move);
	void Apply(const CubeMoveSequence& moves);

	void GenerateRandomState(RandomSource& rng);

	CubePiece& Corner(CubeCorner corner) { return m_corners[corner]; }
	const CubePiece& Corner(CubeCorner corner) const { return m_corners[corner]; }
	CubePiece& Edge(CubeEdge edge) { return m_edges[edge]; }
	const CubePiece& Edge(CubeEdge edge) const { return m_edges[edge]; }

	bool IsSolved();
	bool operator==(const Cube3x3& cube) const;
	bool operator!=(const Cube3x3& cube) const;

	// Index functions are used to identify unique cube states for various aspects of the cube. These
	// are used to quickly prune the search space using pre-generated tables during solving.
	int GetCornerOrientationIndex();
	int GetCornerPermutationIndex();
	int GetEdgeOrientationIndex();
	int GetPhase2EdgePermutationIndex();
	int GetEquatorialEdgeSliceIndex();
	int GetPhase2EquatorialEdgePermutationIndex();

	// Generates moves sequence that will solve the current cube state. If optimal is false, return
	// the first found valid solution, which will be at most 30 moves, for a quicker result.
	CubeMoveSequence Solve(bool optimal = true);
};

// Representation of a 3x3x3 cube using face color format
class Cube3x3Faces
{
	CubeColor m_state[6 * 9];

	static uint8_t m_cornerAdjacency[6][4][2];
	static uint8_t m_edgeAdjacency[6][4];
	static uint8_t m_faceRotation[2][9];
	static uint8_t m_edgeRotation[2][4];
	static uint8_t m_cornerRotation[2][4];
	static uint8_t m_cornerIndicies[8][3];
	static uint8_t m_edgeIndicies[12][2];

public:
	Cube3x3Faces();
	Cube3x3Faces(const Cube3x3& cube);

	void Rotate(CubeFace face, CubeRotationDirection dir);
	void Move(CubeMove move);
	void Apply(const CubeMoveSequence& moves);

	CubeColor GetColor(CubeFace face, uint8_t row, uint8_t col) const;
	CubeColor GetCornerColor(CubeCorner corner, size_t i) const;
	CubeColor GetEdgeColor(CubeEdge edge, size_t i) const;

	bool IsSolved() const;
	bool operator==(const Cube3x3Faces& cube) const;
	bool operator!=(const Cube3x3Faces& cube) const;

	CubeMoveSequence Solve(bool optimal = true);

	void PrintDebugState() const;
};

class Cube3x3RandomStateScramble: public Scrambler
{
public:
	virtual std::string GetName() override { return "3x3x3 random state"; }
	virtual CubeMoveSequence GetScramble(RandomSource& rng) override;
	virtual size_t GetMaxMoveCount() override { return MAX_3X3_SOLUTION_MOVES; }
};
