// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DATABASE_DATABASE_H_
#define FLATBUFFERS_GENERATED_DATABASE_DATABASE_H_

#include "flatbuffers/flatbuffers.h"

namespace database {

struct Update;

struct CubeSolveMove;

struct CubeSolveSplits;

struct CubeSolve;

struct SolveList;

struct Session;

struct SessionList;

struct Data;

enum SolveType {
  SolveType_SOLVE_3X3X3 = 0,
  SolveType_SOLVE_3X3X3_OH = 1,
  SolveType_SOLVE_3X3X3_BF = 2,
  SolveType_SOLVE_2X2X2 = 3,
  SolveType_SOLVE_4X4X4 = 4,
  SolveType_SOLVE_4X4X4_BF = 5,
  SolveType_SOLVE_5X5X5 = 6,
  SolveType_SOLVE_5X5X5_BF = 7,
  SolveType_MIN = SolveType_SOLVE_3X3X3,
  SolveType_MAX = SolveType_SOLVE_5X5X5_BF
};

inline const SolveType (&EnumValuesSolveType())[8] {
  static const SolveType values[] = {
    SolveType_SOLVE_3X3X3,
    SolveType_SOLVE_3X3X3_OH,
    SolveType_SOLVE_3X3X3_BF,
    SolveType_SOLVE_2X2X2,
    SolveType_SOLVE_4X4X4,
    SolveType_SOLVE_4X4X4_BF,
    SolveType_SOLVE_5X5X5,
    SolveType_SOLVE_5X5X5_BF
  };
  return values;
}

inline const char * const *EnumNamesSolveType() {
  static const char * const names[] = {
    "SOLVE_3X3X3",
    "SOLVE_3X3X3_OH",
    "SOLVE_3X3X3_BF",
    "SOLVE_2X2X2",
    "SOLVE_4X4X4",
    "SOLVE_4X4X4_BF",
    "SOLVE_5X5X5",
    "SOLVE_5X5X5_BF",
    nullptr
  };
  return names;
}

inline const char *EnumNameSolveType(SolveType e) {
  if (e < SolveType_SOLVE_3X3X3 || e > SolveType_SOLVE_5X5X5_BF) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSolveType()[index];
}

enum CubeMove {
  CubeMove_MOVE_U = 0,
  CubeMove_MOVE_Up = 1,
  CubeMove_MOVE_U2 = 2,
  CubeMove_MOVE_F = 3,
  CubeMove_MOVE_Fp = 4,
  CubeMove_MOVE_F2 = 5,
  CubeMove_MOVE_R = 6,
  CubeMove_MOVE_Rp = 7,
  CubeMove_MOVE_R2 = 8,
  CubeMove_MOVE_B = 9,
  CubeMove_MOVE_Bp = 10,
  CubeMove_MOVE_B2 = 11,
  CubeMove_MOVE_L = 12,
  CubeMove_MOVE_Lp = 13,
  CubeMove_MOVE_L2 = 14,
  CubeMove_MOVE_D = 15,
  CubeMove_MOVE_Dp = 16,
  CubeMove_MOVE_D2 = 17,
  CubeMove_MIN = CubeMove_MOVE_U,
  CubeMove_MAX = CubeMove_MOVE_D2
};

inline const CubeMove (&EnumValuesCubeMove())[18] {
  static const CubeMove values[] = {
    CubeMove_MOVE_U,
    CubeMove_MOVE_Up,
    CubeMove_MOVE_U2,
    CubeMove_MOVE_F,
    CubeMove_MOVE_Fp,
    CubeMove_MOVE_F2,
    CubeMove_MOVE_R,
    CubeMove_MOVE_Rp,
    CubeMove_MOVE_R2,
    CubeMove_MOVE_B,
    CubeMove_MOVE_Bp,
    CubeMove_MOVE_B2,
    CubeMove_MOVE_L,
    CubeMove_MOVE_Lp,
    CubeMove_MOVE_L2,
    CubeMove_MOVE_D,
    CubeMove_MOVE_Dp,
    CubeMove_MOVE_D2
  };
  return values;
}

inline const char * const *EnumNamesCubeMove() {
  static const char * const names[] = {
    "MOVE_U",
    "MOVE_Up",
    "MOVE_U2",
    "MOVE_F",
    "MOVE_Fp",
    "MOVE_F2",
    "MOVE_R",
    "MOVE_Rp",
    "MOVE_R2",
    "MOVE_B",
    "MOVE_Bp",
    "MOVE_B2",
    "MOVE_L",
    "MOVE_Lp",
    "MOVE_L2",
    "MOVE_D",
    "MOVE_Dp",
    "MOVE_D2",
    nullptr
  };
  return names;
}

inline const char *EnumNameCubeMove(CubeMove e) {
  if (e < CubeMove_MOVE_U || e > CubeMove_MOVE_D2) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCubeMove()[index];
}

enum Contents {
  Contents_NONE = 0,
  Contents_cube_solve = 1,
  Contents_solve_list = 2,
  Contents_session = 3,
  Contents_session_list = 4,
  Contents_MIN = Contents_NONE,
  Contents_MAX = Contents_session_list
};

inline const Contents (&EnumValuesContents())[5] {
  static const Contents values[] = {
    Contents_NONE,
    Contents_cube_solve,
    Contents_solve_list,
    Contents_session,
    Contents_session_list
  };
  return values;
}

inline const char * const *EnumNamesContents() {
  static const char * const names[] = {
    "NONE",
    "cube_solve",
    "solve_list",
    "session",
    "session_list",
    nullptr
  };
  return names;
}

inline const char *EnumNameContents(Contents e) {
  if (e < Contents_NONE || e > Contents_session_list) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesContents()[index];
}

template<typename T> struct ContentsTraits {
  static const Contents enum_value = Contents_NONE;
};

template<> struct ContentsTraits<CubeSolve> {
  static const Contents enum_value = Contents_cube_solve;
};

template<> struct ContentsTraits<SolveList> {
  static const Contents enum_value = Contents_solve_list;
};

template<> struct ContentsTraits<Session> {
  static const Contents enum_value = Contents_session;
};

template<> struct ContentsTraits<SessionList> {
  static const Contents enum_value = Contents_session_list;
};

bool VerifyContents(flatbuffers::Verifier &verifier, const void *obj, Contents type);
bool VerifyContentsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Update FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TIME = 6,
    VT_SYNC = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  uint32_t time() const {
    return GetField<uint32_t>(VT_TIME, 0);
  }
  const flatbuffers::String *sync() const {
    return GetPointer<const flatbuffers::String *>(VT_SYNC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint32_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_SYNC) &&
           verifier.VerifyString(sync()) &&
           verifier.EndTable();
  }
};

struct UpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Update::VT_ID, id);
  }
  void add_time(uint32_t time) {
    fbb_.AddElement<uint32_t>(Update::VT_TIME, time, 0);
  }
  void add_sync(flatbuffers::Offset<flatbuffers::String> sync) {
    fbb_.AddOffset(Update::VT_SYNC, sync);
  }
  explicit UpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateBuilder &operator=(const UpdateBuilder &);
  flatbuffers::Offset<Update> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Update>(end);
    return o;
  }
};

inline flatbuffers::Offset<Update> CreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    uint32_t time = 0,
    flatbuffers::Offset<flatbuffers::String> sync = 0) {
  UpdateBuilder builder_(_fbb);
  builder_.add_sync(sync);
  builder_.add_time(time);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Update> CreateUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    uint32_t time = 0,
    const char *sync = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto sync__ = sync ? _fbb.CreateString(sync) : 0;
  return database::CreateUpdate(
      _fbb,
      id__,
      time,
      sync__);
}

struct CubeSolveMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOVE = 4,
    VT_MILLISECONDS = 6
  };
  CubeMove move() const {
    return static_cast<CubeMove>(GetField<uint8_t>(VT_MOVE, 0));
  }
  uint32_t milliseconds() const {
    return GetField<uint32_t>(VT_MILLISECONDS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MOVE) &&
           VerifyField<uint32_t>(verifier, VT_MILLISECONDS) &&
           verifier.EndTable();
  }
};

struct CubeSolveMoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_move(CubeMove move) {
    fbb_.AddElement<uint8_t>(CubeSolveMove::VT_MOVE, static_cast<uint8_t>(move), 0);
  }
  void add_milliseconds(uint32_t milliseconds) {
    fbb_.AddElement<uint32_t>(CubeSolveMove::VT_MILLISECONDS, milliseconds, 0);
  }
  explicit CubeSolveMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CubeSolveMoveBuilder &operator=(const CubeSolveMoveBuilder &);
  flatbuffers::Offset<CubeSolveMove> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CubeSolveMove>(end);
    return o;
  }
};

inline flatbuffers::Offset<CubeSolveMove> CreateCubeSolveMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    CubeMove move = CubeMove_MOVE_U,
    uint32_t milliseconds = 0) {
  CubeSolveMoveBuilder builder_(_fbb);
  builder_.add_milliseconds(milliseconds);
  builder_.add_move(move);
  return builder_.Finish();
}

struct CubeSolveSplits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CROSS_TIME = 4,
    VT_F2L_FIRST_PAIR_TIME = 6,
    VT_F2L_SECOND_PAIR_TIME = 8,
    VT_F2L_THIRD_PAIR_TIME = 10,
    VT_F2L_FINISH_TIME = 12,
    VT_OLL_CROSS_TIME = 14,
    VT_OLL_FINISH_TIME = 16,
    VT_PLL_CORNER_TIME = 18
  };
  uint32_t cross_time() const {
    return GetField<uint32_t>(VT_CROSS_TIME, 0);
  }
  uint32_t f2l_first_pair_time() const {
    return GetField<uint32_t>(VT_F2L_FIRST_PAIR_TIME, 0);
  }
  uint32_t f2l_second_pair_time() const {
    return GetField<uint32_t>(VT_F2L_SECOND_PAIR_TIME, 0);
  }
  uint32_t f2l_third_pair_time() const {
    return GetField<uint32_t>(VT_F2L_THIRD_PAIR_TIME, 0);
  }
  uint32_t f2l_finish_time() const {
    return GetField<uint32_t>(VT_F2L_FINISH_TIME, 0);
  }
  uint32_t oll_cross_time() const {
    return GetField<uint32_t>(VT_OLL_CROSS_TIME, 0);
  }
  uint32_t oll_finish_time() const {
    return GetField<uint32_t>(VT_OLL_FINISH_TIME, 0);
  }
  uint32_t pll_corner_time() const {
    return GetField<uint32_t>(VT_PLL_CORNER_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CROSS_TIME) &&
           VerifyField<uint32_t>(verifier, VT_F2L_FIRST_PAIR_TIME) &&
           VerifyField<uint32_t>(verifier, VT_F2L_SECOND_PAIR_TIME) &&
           VerifyField<uint32_t>(verifier, VT_F2L_THIRD_PAIR_TIME) &&
           VerifyField<uint32_t>(verifier, VT_F2L_FINISH_TIME) &&
           VerifyField<uint32_t>(verifier, VT_OLL_CROSS_TIME) &&
           VerifyField<uint32_t>(verifier, VT_OLL_FINISH_TIME) &&
           VerifyField<uint32_t>(verifier, VT_PLL_CORNER_TIME) &&
           verifier.EndTable();
  }
};

struct CubeSolveSplitsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cross_time(uint32_t cross_time) {
    fbb_.AddElement<uint32_t>(CubeSolveSplits::VT_CROSS_TIME, cross_time, 0);
  }
  void add_f2l_first_pair_time(uint32_t f2l_first_pair_time) {
    fbb_.AddElement<uint32_t>(CubeSolveSplits::VT_F2L_FIRST_PAIR_TIME, f2l_first_pair_time, 0);
  }
  void add_f2l_second_pair_time(uint32_t f2l_second_pair_time) {
    fbb_.AddElement<uint32_t>(CubeSolveSplits::VT_F2L_SECOND_PAIR_TIME, f2l_second_pair_time, 0);
  }
  void add_f2l_third_pair_time(uint32_t f2l_third_pair_time) {
    fbb_.AddElement<uint32_t>(CubeSolveSplits::VT_F2L_THIRD_PAIR_TIME, f2l_third_pair_time, 0);
  }
  void add_f2l_finish_time(uint32_t f2l_finish_time) {
    fbb_.AddElement<uint32_t>(CubeSolveSplits::VT_F2L_FINISH_TIME, f2l_finish_time, 0);
  }
  void add_oll_cross_time(uint32_t oll_cross_time) {
    fbb_.AddElement<uint32_t>(CubeSolveSplits::VT_OLL_CROSS_TIME, oll_cross_time, 0);
  }
  void add_oll_finish_time(uint32_t oll_finish_time) {
    fbb_.AddElement<uint32_t>(CubeSolveSplits::VT_OLL_FINISH_TIME, oll_finish_time, 0);
  }
  void add_pll_corner_time(uint32_t pll_corner_time) {
    fbb_.AddElement<uint32_t>(CubeSolveSplits::VT_PLL_CORNER_TIME, pll_corner_time, 0);
  }
  explicit CubeSolveSplitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CubeSolveSplitsBuilder &operator=(const CubeSolveSplitsBuilder &);
  flatbuffers::Offset<CubeSolveSplits> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CubeSolveSplits>(end);
    return o;
  }
};

inline flatbuffers::Offset<CubeSolveSplits> CreateCubeSolveSplits(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t cross_time = 0,
    uint32_t f2l_first_pair_time = 0,
    uint32_t f2l_second_pair_time = 0,
    uint32_t f2l_third_pair_time = 0,
    uint32_t f2l_finish_time = 0,
    uint32_t oll_cross_time = 0,
    uint32_t oll_finish_time = 0,
    uint32_t pll_corner_time = 0) {
  CubeSolveSplitsBuilder builder_(_fbb);
  builder_.add_pll_corner_time(pll_corner_time);
  builder_.add_oll_finish_time(oll_finish_time);
  builder_.add_oll_cross_time(oll_cross_time);
  builder_.add_f2l_finish_time(f2l_finish_time);
  builder_.add_f2l_third_pair_time(f2l_third_pair_time);
  builder_.add_f2l_second_pair_time(f2l_second_pair_time);
  builder_.add_f2l_first_pair_time(f2l_first_pair_time);
  builder_.add_cross_time(cross_time);
  return builder_.Finish();
}

struct CubeSolve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCRAMBLE = 4,
    VT_CREATED = 6,
    VT_UPDATE = 8,
    VT_OK = 10,
    VT_TIME = 12,
    VT_PENALTY = 14,
    VT_SOLVE_DEVICE = 16,
    VT_SOLVE_MOVES = 18,
    VT_SOLVE_SPLITS = 20
  };
  const flatbuffers::Vector<uint8_t> *scramble() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SCRAMBLE);
  }
  uint64_t created() const {
    return GetField<uint64_t>(VT_CREATED, 0);
  }
  const Update *update() const {
    return GetPointer<const Update *>(VT_UPDATE);
  }
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 0) != 0;
  }
  uint32_t time() const {
    return GetField<uint32_t>(VT_TIME, 0);
  }
  uint32_t penalty() const {
    return GetField<uint32_t>(VT_PENALTY, 0);
  }
  const flatbuffers::String *solve_device() const {
    return GetPointer<const flatbuffers::String *>(VT_SOLVE_DEVICE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CubeSolveMove>> *solve_moves() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CubeSolveMove>> *>(VT_SOLVE_MOVES);
  }
  const CubeSolveSplits *solve_splits() const {
    return GetPointer<const CubeSolveSplits *>(VT_SOLVE_SPLITS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCRAMBLE) &&
           verifier.VerifyVector(scramble()) &&
           VerifyField<uint64_t>(verifier, VT_CREATED) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyField<uint8_t>(verifier, VT_OK) &&
           VerifyField<uint32_t>(verifier, VT_TIME) &&
           VerifyField<uint32_t>(verifier, VT_PENALTY) &&
           VerifyOffset(verifier, VT_SOLVE_DEVICE) &&
           verifier.VerifyString(solve_device()) &&
           VerifyOffset(verifier, VT_SOLVE_MOVES) &&
           verifier.VerifyVector(solve_moves()) &&
           verifier.VerifyVectorOfTables(solve_moves()) &&
           VerifyOffset(verifier, VT_SOLVE_SPLITS) &&
           verifier.VerifyTable(solve_splits()) &&
           verifier.EndTable();
  }
};

struct CubeSolveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scramble(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> scramble) {
    fbb_.AddOffset(CubeSolve::VT_SCRAMBLE, scramble);
  }
  void add_created(uint64_t created) {
    fbb_.AddElement<uint64_t>(CubeSolve::VT_CREATED, created, 0);
  }
  void add_update(flatbuffers::Offset<Update> update) {
    fbb_.AddOffset(CubeSolve::VT_UPDATE, update);
  }
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(CubeSolve::VT_OK, static_cast<uint8_t>(ok), 0);
  }
  void add_time(uint32_t time) {
    fbb_.AddElement<uint32_t>(CubeSolve::VT_TIME, time, 0);
  }
  void add_penalty(uint32_t penalty) {
    fbb_.AddElement<uint32_t>(CubeSolve::VT_PENALTY, penalty, 0);
  }
  void add_solve_device(flatbuffers::Offset<flatbuffers::String> solve_device) {
    fbb_.AddOffset(CubeSolve::VT_SOLVE_DEVICE, solve_device);
  }
  void add_solve_moves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CubeSolveMove>>> solve_moves) {
    fbb_.AddOffset(CubeSolve::VT_SOLVE_MOVES, solve_moves);
  }
  void add_solve_splits(flatbuffers::Offset<CubeSolveSplits> solve_splits) {
    fbb_.AddOffset(CubeSolve::VT_SOLVE_SPLITS, solve_splits);
  }
  explicit CubeSolveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CubeSolveBuilder &operator=(const CubeSolveBuilder &);
  flatbuffers::Offset<CubeSolve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CubeSolve>(end);
    return o;
  }
};

inline flatbuffers::Offset<CubeSolve> CreateCubeSolve(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> scramble = 0,
    uint64_t created = 0,
    flatbuffers::Offset<Update> update = 0,
    bool ok = false,
    uint32_t time = 0,
    uint32_t penalty = 0,
    flatbuffers::Offset<flatbuffers::String> solve_device = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CubeSolveMove>>> solve_moves = 0,
    flatbuffers::Offset<CubeSolveSplits> solve_splits = 0) {
  CubeSolveBuilder builder_(_fbb);
  builder_.add_created(created);
  builder_.add_solve_splits(solve_splits);
  builder_.add_solve_moves(solve_moves);
  builder_.add_solve_device(solve_device);
  builder_.add_penalty(penalty);
  builder_.add_time(time);
  builder_.add_update(update);
  builder_.add_scramble(scramble);
  builder_.add_ok(ok);
  return builder_.Finish();
}

inline flatbuffers::Offset<CubeSolve> CreateCubeSolveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *scramble = nullptr,
    uint64_t created = 0,
    flatbuffers::Offset<Update> update = 0,
    bool ok = false,
    uint32_t time = 0,
    uint32_t penalty = 0,
    const char *solve_device = nullptr,
    const std::vector<flatbuffers::Offset<CubeSolveMove>> *solve_moves = nullptr,
    flatbuffers::Offset<CubeSolveSplits> solve_splits = 0) {
  auto scramble__ = scramble ? _fbb.CreateVector<uint8_t>(*scramble) : 0;
  auto solve_device__ = solve_device ? _fbb.CreateString(solve_device) : 0;
  auto solve_moves__ = solve_moves ? _fbb.CreateVector<flatbuffers::Offset<CubeSolveMove>>(*solve_moves) : 0;
  return database::CreateCubeSolve(
      _fbb,
      scramble__,
      created,
      update,
      ok,
      time,
      penalty,
      solve_device__,
      solve_moves__,
      solve_splits);
}

struct SolveList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOLVES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *solves() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SOLVES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOLVES) &&
           verifier.VerifyVector(solves()) &&
           verifier.VerifyVectorOfStrings(solves()) &&
           verifier.EndTable();
  }
};

struct SolveListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_solves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> solves) {
    fbb_.AddOffset(SolveList::VT_SOLVES, solves);
  }
  explicit SolveListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SolveListBuilder &operator=(const SolveListBuilder &);
  flatbuffers::Offset<SolveList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SolveList>(end);
    return o;
  }
};

inline flatbuffers::Offset<SolveList> CreateSolveList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> solves = 0) {
  SolveListBuilder builder_(_fbb);
  builder_.add_solves(solves);
  return builder_.Finish();
}

inline flatbuffers::Offset<SolveList> CreateSolveListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *solves = nullptr) {
  auto solves__ = solves ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*solves) : 0;
  return database::CreateSolveList(
      _fbb,
      solves__);
}

struct Session FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_UPDATE = 8
  };
  SolveType type() const {
    return static_cast<SolveType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Update *update() const {
    return GetPointer<const Update *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
};

struct SessionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(SolveType type) {
    fbb_.AddElement<uint8_t>(Session::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Session::VT_NAME, name);
  }
  void add_update(flatbuffers::Offset<Update> update) {
    fbb_.AddOffset(Session::VT_UPDATE, update);
  }
  explicit SessionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SessionBuilder &operator=(const SessionBuilder &);
  flatbuffers::Offset<Session> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Session>(end);
    return o;
  }
};

inline flatbuffers::Offset<Session> CreateSession(
    flatbuffers::FlatBufferBuilder &_fbb,
    SolveType type = SolveType_SOLVE_3X3X3,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Update> update = 0) {
  SessionBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Session> CreateSessionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    SolveType type = SolveType_SOLVE_3X3X3,
    const char *name = nullptr,
    flatbuffers::Offset<Update> update = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return database::CreateSession(
      _fbb,
      type,
      name__,
      update);
}

struct SessionList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *sessions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SESSIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSIONS) &&
           verifier.VerifyVector(sessions()) &&
           verifier.VerifyVectorOfStrings(sessions()) &&
           verifier.EndTable();
  }
};

struct SessionListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sessions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> sessions) {
    fbb_.AddOffset(SessionList::VT_SESSIONS, sessions);
  }
  explicit SessionListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SessionListBuilder &operator=(const SessionListBuilder &);
  flatbuffers::Offset<SessionList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SessionList>(end);
    return o;
  }
};

inline flatbuffers::Offset<SessionList> CreateSessionList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> sessions = 0) {
  SessionListBuilder builder_(_fbb);
  builder_.add_sessions(sessions);
  return builder_.Finish();
}

inline flatbuffers::Offset<SessionList> CreateSessionListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *sessions = nullptr) {
  auto sessions__ = sessions ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*sessions) : 0;
  return database::CreateSessionList(
      _fbb,
      sessions__);
}

struct Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENTS_TYPE = 4,
    VT_CONTENTS = 6
  };
  Contents contents_type() const {
    return static_cast<Contents>(GetField<uint8_t>(VT_CONTENTS_TYPE, 0));
  }
  const void *contents() const {
    return GetPointer<const void *>(VT_CONTENTS);
  }
  template<typename T> const T *contents_as() const;
  const CubeSolve *contents_as_cube_solve() const {
    return contents_type() == Contents_cube_solve ? static_cast<const CubeSolve *>(contents()) : nullptr;
  }
  const SolveList *contents_as_solve_list() const {
    return contents_type() == Contents_solve_list ? static_cast<const SolveList *>(contents()) : nullptr;
  }
  const Session *contents_as_session() const {
    return contents_type() == Contents_session ? static_cast<const Session *>(contents()) : nullptr;
  }
  const SessionList *contents_as_session_list() const {
    return contents_type() == Contents_session_list ? static_cast<const SessionList *>(contents()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONTENTS_TYPE) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           VerifyContents(verifier, contents(), contents_type()) &&
           verifier.EndTable();
  }
};

template<> inline const CubeSolve *Data::contents_as<CubeSolve>() const {
  return contents_as_cube_solve();
}

template<> inline const SolveList *Data::contents_as<SolveList>() const {
  return contents_as_solve_list();
}

template<> inline const Session *Data::contents_as<Session>() const {
  return contents_as_session();
}

template<> inline const SessionList *Data::contents_as<SessionList>() const {
  return contents_as_session_list();
}

struct DataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contents_type(Contents contents_type) {
    fbb_.AddElement<uint8_t>(Data::VT_CONTENTS_TYPE, static_cast<uint8_t>(contents_type), 0);
  }
  void add_contents(flatbuffers::Offset<void> contents) {
    fbb_.AddOffset(Data::VT_CONTENTS, contents);
  }
  explicit DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataBuilder &operator=(const DataBuilder &);
  flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<Data> CreateData(
    flatbuffers::FlatBufferBuilder &_fbb,
    Contents contents_type = Contents_NONE,
    flatbuffers::Offset<void> contents = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_contents(contents);
  builder_.add_contents_type(contents_type);
  return builder_.Finish();
}

inline bool VerifyContents(flatbuffers::Verifier &verifier, const void *obj, Contents type) {
  switch (type) {
    case Contents_NONE: {
      return true;
    }
    case Contents_cube_solve: {
      auto ptr = reinterpret_cast<const CubeSolve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Contents_solve_list: {
      auto ptr = reinterpret_cast<const SolveList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Contents_session: {
      auto ptr = reinterpret_cast<const Session *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Contents_session_list: {
      auto ptr = reinterpret_cast<const SessionList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyContentsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyContents(
        verifier,  values->Get(i), types->GetEnum<Contents>(i))) {
      return false;
    }
  }
  return true;
}

inline const database::Data *GetData(const void *buf) {
  return flatbuffers::GetRoot<database::Data>(buf);
}

inline const database::Data *GetSizePrefixedData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<database::Data>(buf);
}

inline bool VerifyDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<database::Data>(nullptr);
}

inline bool VerifySizePrefixedDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<database::Data>(nullptr);
}

inline void FinishDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<database::Data> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<database::Data> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace database

#endif  // FLATBUFFERS_GENERATED_DATABASE_DATABASE_H_
